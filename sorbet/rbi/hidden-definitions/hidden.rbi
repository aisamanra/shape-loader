# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::Specification
  extend ::Enumerable
end

module Gosu
  GP_0_BUTTON_0 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_1 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_10 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_11 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_12 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_13 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_14 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_15 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_2 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_3 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_4 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_5 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_6 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_7 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_8 = ::T.let(nil, ::T.untyped)
  GP_0_BUTTON_9 = ::T.let(nil, ::T.untyped)
  GP_0_DOWN = ::T.let(nil, ::T.untyped)
  GP_0_LEFT = ::T.let(nil, ::T.untyped)
  GP_0_RIGHT = ::T.let(nil, ::T.untyped)
  GP_0_UP = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_0 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_1 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_10 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_11 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_12 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_13 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_14 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_15 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_2 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_3 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_4 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_5 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_6 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_7 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_8 = ::T.let(nil, ::T.untyped)
  GP_1_BUTTON_9 = ::T.let(nil, ::T.untyped)
  GP_1_DOWN = ::T.let(nil, ::T.untyped)
  GP_1_LEFT = ::T.let(nil, ::T.untyped)
  GP_1_RIGHT = ::T.let(nil, ::T.untyped)
  GP_1_UP = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_0 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_1 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_10 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_11 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_12 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_13 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_14 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_15 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_2 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_3 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_4 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_5 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_6 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_7 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_8 = ::T.let(nil, ::T.untyped)
  GP_2_BUTTON_9 = ::T.let(nil, ::T.untyped)
  GP_2_DOWN = ::T.let(nil, ::T.untyped)
  GP_2_LEFT = ::T.let(nil, ::T.untyped)
  GP_2_RIGHT = ::T.let(nil, ::T.untyped)
  GP_2_UP = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_0 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_1 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_10 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_11 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_12 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_13 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_14 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_15 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_2 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_3 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_4 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_5 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_6 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_7 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_8 = ::T.let(nil, ::T.untyped)
  GP_3_BUTTON_9 = ::T.let(nil, ::T.untyped)
  GP_3_DOWN = ::T.let(nil, ::T.untyped)
  GP_3_LEFT = ::T.let(nil, ::T.untyped)
  GP_3_RIGHT = ::T.let(nil, ::T.untyped)
  GP_3_UP = ::T.let(nil, ::T.untyped)
  GP_BUTTON_0 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_1 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_10 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_11 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_12 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_13 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_14 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_15 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_2 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_3 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_4 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_5 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_6 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_7 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_8 = ::T.let(nil, ::T.untyped)
  GP_BUTTON_9 = ::T.let(nil, ::T.untyped)
  Gp0Button0 = ::T.let(nil, ::T.untyped)
  Gp0Button1 = ::T.let(nil, ::T.untyped)
  Gp0Button10 = ::T.let(nil, ::T.untyped)
  Gp0Button11 = ::T.let(nil, ::T.untyped)
  Gp0Button12 = ::T.let(nil, ::T.untyped)
  Gp0Button13 = ::T.let(nil, ::T.untyped)
  Gp0Button14 = ::T.let(nil, ::T.untyped)
  Gp0Button15 = ::T.let(nil, ::T.untyped)
  Gp0Button2 = ::T.let(nil, ::T.untyped)
  Gp0Button3 = ::T.let(nil, ::T.untyped)
  Gp0Button4 = ::T.let(nil, ::T.untyped)
  Gp0Button5 = ::T.let(nil, ::T.untyped)
  Gp0Button6 = ::T.let(nil, ::T.untyped)
  Gp0Button7 = ::T.let(nil, ::T.untyped)
  Gp0Button8 = ::T.let(nil, ::T.untyped)
  Gp0Button9 = ::T.let(nil, ::T.untyped)
  Gp0Down = ::T.let(nil, ::T.untyped)
  Gp0Left = ::T.let(nil, ::T.untyped)
  Gp0Right = ::T.let(nil, ::T.untyped)
  Gp0Up = ::T.let(nil, ::T.untyped)
  Gp1Button0 = ::T.let(nil, ::T.untyped)
  Gp1Button1 = ::T.let(nil, ::T.untyped)
  Gp1Button10 = ::T.let(nil, ::T.untyped)
  Gp1Button11 = ::T.let(nil, ::T.untyped)
  Gp1Button12 = ::T.let(nil, ::T.untyped)
  Gp1Button13 = ::T.let(nil, ::T.untyped)
  Gp1Button14 = ::T.let(nil, ::T.untyped)
  Gp1Button15 = ::T.let(nil, ::T.untyped)
  Gp1Button2 = ::T.let(nil, ::T.untyped)
  Gp1Button3 = ::T.let(nil, ::T.untyped)
  Gp1Button4 = ::T.let(nil, ::T.untyped)
  Gp1Button5 = ::T.let(nil, ::T.untyped)
  Gp1Button6 = ::T.let(nil, ::T.untyped)
  Gp1Button7 = ::T.let(nil, ::T.untyped)
  Gp1Button8 = ::T.let(nil, ::T.untyped)
  Gp1Button9 = ::T.let(nil, ::T.untyped)
  Gp1Down = ::T.let(nil, ::T.untyped)
  Gp1Left = ::T.let(nil, ::T.untyped)
  Gp1Right = ::T.let(nil, ::T.untyped)
  Gp1Up = ::T.let(nil, ::T.untyped)
  Gp2Button0 = ::T.let(nil, ::T.untyped)
  Gp2Button1 = ::T.let(nil, ::T.untyped)
  Gp2Button10 = ::T.let(nil, ::T.untyped)
  Gp2Button11 = ::T.let(nil, ::T.untyped)
  Gp2Button12 = ::T.let(nil, ::T.untyped)
  Gp2Button13 = ::T.let(nil, ::T.untyped)
  Gp2Button14 = ::T.let(nil, ::T.untyped)
  Gp2Button15 = ::T.let(nil, ::T.untyped)
  Gp2Button2 = ::T.let(nil, ::T.untyped)
  Gp2Button3 = ::T.let(nil, ::T.untyped)
  Gp2Button4 = ::T.let(nil, ::T.untyped)
  Gp2Button5 = ::T.let(nil, ::T.untyped)
  Gp2Button6 = ::T.let(nil, ::T.untyped)
  Gp2Button7 = ::T.let(nil, ::T.untyped)
  Gp2Button8 = ::T.let(nil, ::T.untyped)
  Gp2Button9 = ::T.let(nil, ::T.untyped)
  Gp2Down = ::T.let(nil, ::T.untyped)
  Gp2Left = ::T.let(nil, ::T.untyped)
  Gp2Right = ::T.let(nil, ::T.untyped)
  Gp2Up = ::T.let(nil, ::T.untyped)
  Gp3Button0 = ::T.let(nil, ::T.untyped)
  Gp3Button1 = ::T.let(nil, ::T.untyped)
  Gp3Button10 = ::T.let(nil, ::T.untyped)
  Gp3Button11 = ::T.let(nil, ::T.untyped)
  Gp3Button12 = ::T.let(nil, ::T.untyped)
  Gp3Button13 = ::T.let(nil, ::T.untyped)
  Gp3Button14 = ::T.let(nil, ::T.untyped)
  Gp3Button15 = ::T.let(nil, ::T.untyped)
  Gp3Button2 = ::T.let(nil, ::T.untyped)
  Gp3Button3 = ::T.let(nil, ::T.untyped)
  Gp3Button4 = ::T.let(nil, ::T.untyped)
  Gp3Button5 = ::T.let(nil, ::T.untyped)
  Gp3Button6 = ::T.let(nil, ::T.untyped)
  Gp3Button7 = ::T.let(nil, ::T.untyped)
  Gp3Button8 = ::T.let(nil, ::T.untyped)
  Gp3Button9 = ::T.let(nil, ::T.untyped)
  Gp3Down = ::T.let(nil, ::T.untyped)
  Gp3Left = ::T.let(nil, ::T.untyped)
  Gp3Right = ::T.let(nil, ::T.untyped)
  Gp3Up = ::T.let(nil, ::T.untyped)
  GpButton0 = ::T.let(nil, ::T.untyped)
  GpButton1 = ::T.let(nil, ::T.untyped)
  GpButton10 = ::T.let(nil, ::T.untyped)
  GpButton11 = ::T.let(nil, ::T.untyped)
  GpButton12 = ::T.let(nil, ::T.untyped)
  GpButton13 = ::T.let(nil, ::T.untyped)
  GpButton14 = ::T.let(nil, ::T.untyped)
  GpButton15 = ::T.let(nil, ::T.untyped)
  GpButton2 = ::T.let(nil, ::T.untyped)
  GpButton3 = ::T.let(nil, ::T.untyped)
  GpButton4 = ::T.let(nil, ::T.untyped)
  GpButton5 = ::T.let(nil, ::T.untyped)
  GpButton6 = ::T.let(nil, ::T.untyped)
  GpButton7 = ::T.let(nil, ::T.untyped)
  GpButton8 = ::T.let(nil, ::T.untyped)
  GpButton9 = ::T.let(nil, ::T.untyped)
  GpDown = ::T.let(nil, ::T.untyped)
  GpLeft = ::T.let(nil, ::T.untyped)
  GpRight = ::T.let(nil, ::T.untyped)
  GpUp = ::T.let(nil, ::T.untyped)
  KB_0 = ::T.let(nil, ::T.untyped)
  KB_1 = ::T.let(nil, ::T.untyped)
  KB_2 = ::T.let(nil, ::T.untyped)
  KB_3 = ::T.let(nil, ::T.untyped)
  KB_4 = ::T.let(nil, ::T.untyped)
  KB_5 = ::T.let(nil, ::T.untyped)
  KB_6 = ::T.let(nil, ::T.untyped)
  KB_7 = ::T.let(nil, ::T.untyped)
  KB_8 = ::T.let(nil, ::T.untyped)
  KB_9 = ::T.let(nil, ::T.untyped)
  KB_A = ::T.let(nil, ::T.untyped)
  KB_B = ::T.let(nil, ::T.untyped)
  KB_C = ::T.let(nil, ::T.untyped)
  KB_D = ::T.let(nil, ::T.untyped)
  KB_E = ::T.let(nil, ::T.untyped)
  KB_F = ::T.let(nil, ::T.untyped)
  KB_F1 = ::T.let(nil, ::T.untyped)
  KB_F10 = ::T.let(nil, ::T.untyped)
  KB_F11 = ::T.let(nil, ::T.untyped)
  KB_F12 = ::T.let(nil, ::T.untyped)
  KB_F2 = ::T.let(nil, ::T.untyped)
  KB_F3 = ::T.let(nil, ::T.untyped)
  KB_F4 = ::T.let(nil, ::T.untyped)
  KB_F5 = ::T.let(nil, ::T.untyped)
  KB_F6 = ::T.let(nil, ::T.untyped)
  KB_F7 = ::T.let(nil, ::T.untyped)
  KB_F8 = ::T.let(nil, ::T.untyped)
  KB_F9 = ::T.let(nil, ::T.untyped)
  KB_G = ::T.let(nil, ::T.untyped)
  KB_H = ::T.let(nil, ::T.untyped)
  KB_I = ::T.let(nil, ::T.untyped)
  KB_J = ::T.let(nil, ::T.untyped)
  KB_K = ::T.let(nil, ::T.untyped)
  KB_L = ::T.let(nil, ::T.untyped)
  KB_M = ::T.let(nil, ::T.untyped)
  KB_N = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_0 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_1 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_2 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_3 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_4 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_5 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_6 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_7 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_8 = ::T.let(nil, ::T.untyped)
  KB_NUMPAD_9 = ::T.let(nil, ::T.untyped)
  KB_O = ::T.let(nil, ::T.untyped)
  KB_P = ::T.let(nil, ::T.untyped)
  KB_Q = ::T.let(nil, ::T.untyped)
  KB_R = ::T.let(nil, ::T.untyped)
  KB_S = ::T.let(nil, ::T.untyped)
  KB_T = ::T.let(nil, ::T.untyped)
  KB_U = ::T.let(nil, ::T.untyped)
  KB_V = ::T.let(nil, ::T.untyped)
  KB_W = ::T.let(nil, ::T.untyped)
  KB_X = ::T.let(nil, ::T.untyped)
  KB_Y = ::T.let(nil, ::T.untyped)
  KB_Z = ::T.let(nil, ::T.untyped)
  Kb0 = ::T.let(nil, ::T.untyped)
  Kb1 = ::T.let(nil, ::T.untyped)
  Kb2 = ::T.let(nil, ::T.untyped)
  Kb3 = ::T.let(nil, ::T.untyped)
  Kb4 = ::T.let(nil, ::T.untyped)
  Kb5 = ::T.let(nil, ::T.untyped)
  Kb6 = ::T.let(nil, ::T.untyped)
  Kb7 = ::T.let(nil, ::T.untyped)
  Kb8 = ::T.let(nil, ::T.untyped)
  Kb9 = ::T.let(nil, ::T.untyped)
  KbA = ::T.let(nil, ::T.untyped)
  KbApostrophe = ::T.let(nil, ::T.untyped)
  KbB = ::T.let(nil, ::T.untyped)
  KbBackslash = ::T.let(nil, ::T.untyped)
  KbBackspace = ::T.let(nil, ::T.untyped)
  KbBacktick = ::T.let(nil, ::T.untyped)
  KbBracketLeft = ::T.let(nil, ::T.untyped)
  KbBracketRight = ::T.let(nil, ::T.untyped)
  KbC = ::T.let(nil, ::T.untyped)
  KbComma = ::T.let(nil, ::T.untyped)
  KbD = ::T.let(nil, ::T.untyped)
  KbDelete = ::T.let(nil, ::T.untyped)
  KbDown = ::T.let(nil, ::T.untyped)
  KbE = ::T.let(nil, ::T.untyped)
  KbEnd = ::T.let(nil, ::T.untyped)
  KbEnter = ::T.let(nil, ::T.untyped)
  KbEqual = ::T.let(nil, ::T.untyped)
  KbEscape = ::T.let(nil, ::T.untyped)
  KbF = ::T.let(nil, ::T.untyped)
  KbF1 = ::T.let(nil, ::T.untyped)
  KbF10 = ::T.let(nil, ::T.untyped)
  KbF11 = ::T.let(nil, ::T.untyped)
  KbF12 = ::T.let(nil, ::T.untyped)
  KbF2 = ::T.let(nil, ::T.untyped)
  KbF3 = ::T.let(nil, ::T.untyped)
  KbF4 = ::T.let(nil, ::T.untyped)
  KbF5 = ::T.let(nil, ::T.untyped)
  KbF6 = ::T.let(nil, ::T.untyped)
  KbF7 = ::T.let(nil, ::T.untyped)
  KbF8 = ::T.let(nil, ::T.untyped)
  KbF9 = ::T.let(nil, ::T.untyped)
  KbG = ::T.let(nil, ::T.untyped)
  KbH = ::T.let(nil, ::T.untyped)
  KbHome = ::T.let(nil, ::T.untyped)
  KbI = ::T.let(nil, ::T.untyped)
  KbISO = ::T.let(nil, ::T.untyped)
  KbInsert = ::T.let(nil, ::T.untyped)
  KbJ = ::T.let(nil, ::T.untyped)
  KbK = ::T.let(nil, ::T.untyped)
  KbL = ::T.let(nil, ::T.untyped)
  KbLeft = ::T.let(nil, ::T.untyped)
  KbLeftAlt = ::T.let(nil, ::T.untyped)
  KbLeftControl = ::T.let(nil, ::T.untyped)
  KbLeftMeta = ::T.let(nil, ::T.untyped)
  KbLeftShift = ::T.let(nil, ::T.untyped)
  KbM = ::T.let(nil, ::T.untyped)
  KbMinus = ::T.let(nil, ::T.untyped)
  KbN = ::T.let(nil, ::T.untyped)
  KbNumpad0 = ::T.let(nil, ::T.untyped)
  KbNumpad1 = ::T.let(nil, ::T.untyped)
  KbNumpad2 = ::T.let(nil, ::T.untyped)
  KbNumpad3 = ::T.let(nil, ::T.untyped)
  KbNumpad4 = ::T.let(nil, ::T.untyped)
  KbNumpad5 = ::T.let(nil, ::T.untyped)
  KbNumpad6 = ::T.let(nil, ::T.untyped)
  KbNumpad7 = ::T.let(nil, ::T.untyped)
  KbNumpad8 = ::T.let(nil, ::T.untyped)
  KbNumpad9 = ::T.let(nil, ::T.untyped)
  KbNumpadAdd = ::T.let(nil, ::T.untyped)
  KbNumpadDelete = ::T.let(nil, ::T.untyped)
  KbNumpadDivide = ::T.let(nil, ::T.untyped)
  KbNumpadMultiply = ::T.let(nil, ::T.untyped)
  KbNumpadSubtract = ::T.let(nil, ::T.untyped)
  KbO = ::T.let(nil, ::T.untyped)
  KbP = ::T.let(nil, ::T.untyped)
  KbPageDown = ::T.let(nil, ::T.untyped)
  KbPageUp = ::T.let(nil, ::T.untyped)
  KbPeriod = ::T.let(nil, ::T.untyped)
  KbQ = ::T.let(nil, ::T.untyped)
  KbR = ::T.let(nil, ::T.untyped)
  KbReturn = ::T.let(nil, ::T.untyped)
  KbRight = ::T.let(nil, ::T.untyped)
  KbRightAlt = ::T.let(nil, ::T.untyped)
  KbRightControl = ::T.let(nil, ::T.untyped)
  KbRightMeta = ::T.let(nil, ::T.untyped)
  KbRightShift = ::T.let(nil, ::T.untyped)
  KbS = ::T.let(nil, ::T.untyped)
  KbSemicolon = ::T.let(nil, ::T.untyped)
  KbSlash = ::T.let(nil, ::T.untyped)
  KbSpace = ::T.let(nil, ::T.untyped)
  KbT = ::T.let(nil, ::T.untyped)
  KbTab = ::T.let(nil, ::T.untyped)
  KbU = ::T.let(nil, ::T.untyped)
  KbUp = ::T.let(nil, ::T.untyped)
  KbV = ::T.let(nil, ::T.untyped)
  KbW = ::T.let(nil, ::T.untyped)
  KbX = ::T.let(nil, ::T.untyped)
  KbY = ::T.let(nil, ::T.untyped)
  KbZ = ::T.let(nil, ::T.untyped)
  MAX_TEXTURE_SIZE = ::T.let(nil, ::T.untyped)
  MS_OTHER_0 = ::T.let(nil, ::T.untyped)
  MS_OTHER_1 = ::T.let(nil, ::T.untyped)
  MS_OTHER_2 = ::T.let(nil, ::T.untyped)
  MS_OTHER_3 = ::T.let(nil, ::T.untyped)
  MS_OTHER_4 = ::T.let(nil, ::T.untyped)
  MS_OTHER_5 = ::T.let(nil, ::T.untyped)
  MS_OTHER_6 = ::T.let(nil, ::T.untyped)
  MS_OTHER_7 = ::T.let(nil, ::T.untyped)
  MsLeft = ::T.let(nil, ::T.untyped)
  MsMiddle = ::T.let(nil, ::T.untyped)
  MsOther0 = ::T.let(nil, ::T.untyped)
  MsOther1 = ::T.let(nil, ::T.untyped)
  MsOther2 = ::T.let(nil, ::T.untyped)
  MsOther3 = ::T.let(nil, ::T.untyped)
  MsOther4 = ::T.let(nil, ::T.untyped)
  MsOther5 = ::T.let(nil, ::T.untyped)
  MsOther6 = ::T.let(nil, ::T.untyped)
  MsOther7 = ::T.let(nil, ::T.untyped)
  MsRight = ::T.let(nil, ::T.untyped)
  MsWheelDown = ::T.let(nil, ::T.untyped)
  MsWheelUp = ::T.let(nil, ::T.untyped)
end

module Gosu::Button
  Gp0Button0 = ::T.let(nil, ::T.untyped)
  Gp0Button1 = ::T.let(nil, ::T.untyped)
  Gp0Button10 = ::T.let(nil, ::T.untyped)
  Gp0Button11 = ::T.let(nil, ::T.untyped)
  Gp0Button12 = ::T.let(nil, ::T.untyped)
  Gp0Button13 = ::T.let(nil, ::T.untyped)
  Gp0Button14 = ::T.let(nil, ::T.untyped)
  Gp0Button15 = ::T.let(nil, ::T.untyped)
  Gp0Button2 = ::T.let(nil, ::T.untyped)
  Gp0Button3 = ::T.let(nil, ::T.untyped)
  Gp0Button4 = ::T.let(nil, ::T.untyped)
  Gp0Button5 = ::T.let(nil, ::T.untyped)
  Gp0Button6 = ::T.let(nil, ::T.untyped)
  Gp0Button7 = ::T.let(nil, ::T.untyped)
  Gp0Button8 = ::T.let(nil, ::T.untyped)
  Gp0Button9 = ::T.let(nil, ::T.untyped)
  Gp0Down = ::T.let(nil, ::T.untyped)
  Gp0Left = ::T.let(nil, ::T.untyped)
  Gp0Right = ::T.let(nil, ::T.untyped)
  Gp0Up = ::T.let(nil, ::T.untyped)
  Gp1Button0 = ::T.let(nil, ::T.untyped)
  Gp1Button1 = ::T.let(nil, ::T.untyped)
  Gp1Button10 = ::T.let(nil, ::T.untyped)
  Gp1Button11 = ::T.let(nil, ::T.untyped)
  Gp1Button12 = ::T.let(nil, ::T.untyped)
  Gp1Button13 = ::T.let(nil, ::T.untyped)
  Gp1Button14 = ::T.let(nil, ::T.untyped)
  Gp1Button15 = ::T.let(nil, ::T.untyped)
  Gp1Button2 = ::T.let(nil, ::T.untyped)
  Gp1Button3 = ::T.let(nil, ::T.untyped)
  Gp1Button4 = ::T.let(nil, ::T.untyped)
  Gp1Button5 = ::T.let(nil, ::T.untyped)
  Gp1Button6 = ::T.let(nil, ::T.untyped)
  Gp1Button7 = ::T.let(nil, ::T.untyped)
  Gp1Button8 = ::T.let(nil, ::T.untyped)
  Gp1Button9 = ::T.let(nil, ::T.untyped)
  Gp1Down = ::T.let(nil, ::T.untyped)
  Gp1Left = ::T.let(nil, ::T.untyped)
  Gp1Right = ::T.let(nil, ::T.untyped)
  Gp1Up = ::T.let(nil, ::T.untyped)
  Gp2Button0 = ::T.let(nil, ::T.untyped)
  Gp2Button1 = ::T.let(nil, ::T.untyped)
  Gp2Button10 = ::T.let(nil, ::T.untyped)
  Gp2Button11 = ::T.let(nil, ::T.untyped)
  Gp2Button12 = ::T.let(nil, ::T.untyped)
  Gp2Button13 = ::T.let(nil, ::T.untyped)
  Gp2Button14 = ::T.let(nil, ::T.untyped)
  Gp2Button15 = ::T.let(nil, ::T.untyped)
  Gp2Button2 = ::T.let(nil, ::T.untyped)
  Gp2Button3 = ::T.let(nil, ::T.untyped)
  Gp2Button4 = ::T.let(nil, ::T.untyped)
  Gp2Button5 = ::T.let(nil, ::T.untyped)
  Gp2Button6 = ::T.let(nil, ::T.untyped)
  Gp2Button7 = ::T.let(nil, ::T.untyped)
  Gp2Button8 = ::T.let(nil, ::T.untyped)
  Gp2Button9 = ::T.let(nil, ::T.untyped)
  Gp2Down = ::T.let(nil, ::T.untyped)
  Gp2Left = ::T.let(nil, ::T.untyped)
  Gp2Right = ::T.let(nil, ::T.untyped)
  Gp2Up = ::T.let(nil, ::T.untyped)
  Gp3Button0 = ::T.let(nil, ::T.untyped)
  Gp3Button1 = ::T.let(nil, ::T.untyped)
  Gp3Button10 = ::T.let(nil, ::T.untyped)
  Gp3Button11 = ::T.let(nil, ::T.untyped)
  Gp3Button12 = ::T.let(nil, ::T.untyped)
  Gp3Button13 = ::T.let(nil, ::T.untyped)
  Gp3Button14 = ::T.let(nil, ::T.untyped)
  Gp3Button15 = ::T.let(nil, ::T.untyped)
  Gp3Button2 = ::T.let(nil, ::T.untyped)
  Gp3Button3 = ::T.let(nil, ::T.untyped)
  Gp3Button4 = ::T.let(nil, ::T.untyped)
  Gp3Button5 = ::T.let(nil, ::T.untyped)
  Gp3Button6 = ::T.let(nil, ::T.untyped)
  Gp3Button7 = ::T.let(nil, ::T.untyped)
  Gp3Button8 = ::T.let(nil, ::T.untyped)
  Gp3Button9 = ::T.let(nil, ::T.untyped)
  Gp3Down = ::T.let(nil, ::T.untyped)
  Gp3Left = ::T.let(nil, ::T.untyped)
  Gp3Right = ::T.let(nil, ::T.untyped)
  Gp3Up = ::T.let(nil, ::T.untyped)
  GpButton0 = ::T.let(nil, ::T.untyped)
  GpButton1 = ::T.let(nil, ::T.untyped)
  GpButton10 = ::T.let(nil, ::T.untyped)
  GpButton11 = ::T.let(nil, ::T.untyped)
  GpButton12 = ::T.let(nil, ::T.untyped)
  GpButton13 = ::T.let(nil, ::T.untyped)
  GpButton14 = ::T.let(nil, ::T.untyped)
  GpButton15 = ::T.let(nil, ::T.untyped)
  GpButton2 = ::T.let(nil, ::T.untyped)
  GpButton3 = ::T.let(nil, ::T.untyped)
  GpButton4 = ::T.let(nil, ::T.untyped)
  GpButton5 = ::T.let(nil, ::T.untyped)
  GpButton6 = ::T.let(nil, ::T.untyped)
  GpButton7 = ::T.let(nil, ::T.untyped)
  GpButton8 = ::T.let(nil, ::T.untyped)
  GpButton9 = ::T.let(nil, ::T.untyped)
  GpDown = ::T.let(nil, ::T.untyped)
  GpLeft = ::T.let(nil, ::T.untyped)
  GpRight = ::T.let(nil, ::T.untyped)
  GpUp = ::T.let(nil, ::T.untyped)
  Kb0 = ::T.let(nil, ::T.untyped)
  Kb1 = ::T.let(nil, ::T.untyped)
  Kb2 = ::T.let(nil, ::T.untyped)
  Kb3 = ::T.let(nil, ::T.untyped)
  Kb4 = ::T.let(nil, ::T.untyped)
  Kb5 = ::T.let(nil, ::T.untyped)
  Kb6 = ::T.let(nil, ::T.untyped)
  Kb7 = ::T.let(nil, ::T.untyped)
  Kb8 = ::T.let(nil, ::T.untyped)
  Kb9 = ::T.let(nil, ::T.untyped)
  KbA = ::T.let(nil, ::T.untyped)
  KbApostrophe = ::T.let(nil, ::T.untyped)
  KbB = ::T.let(nil, ::T.untyped)
  KbBackslash = ::T.let(nil, ::T.untyped)
  KbBackspace = ::T.let(nil, ::T.untyped)
  KbBacktick = ::T.let(nil, ::T.untyped)
  KbBracketLeft = ::T.let(nil, ::T.untyped)
  KbBracketRight = ::T.let(nil, ::T.untyped)
  KbC = ::T.let(nil, ::T.untyped)
  KbComma = ::T.let(nil, ::T.untyped)
  KbD = ::T.let(nil, ::T.untyped)
  KbDelete = ::T.let(nil, ::T.untyped)
  KbDown = ::T.let(nil, ::T.untyped)
  KbE = ::T.let(nil, ::T.untyped)
  KbEnd = ::T.let(nil, ::T.untyped)
  KbEnter = ::T.let(nil, ::T.untyped)
  KbEqual = ::T.let(nil, ::T.untyped)
  KbEscape = ::T.let(nil, ::T.untyped)
  KbF = ::T.let(nil, ::T.untyped)
  KbF1 = ::T.let(nil, ::T.untyped)
  KbF10 = ::T.let(nil, ::T.untyped)
  KbF11 = ::T.let(nil, ::T.untyped)
  KbF12 = ::T.let(nil, ::T.untyped)
  KbF2 = ::T.let(nil, ::T.untyped)
  KbF3 = ::T.let(nil, ::T.untyped)
  KbF4 = ::T.let(nil, ::T.untyped)
  KbF5 = ::T.let(nil, ::T.untyped)
  KbF6 = ::T.let(nil, ::T.untyped)
  KbF7 = ::T.let(nil, ::T.untyped)
  KbF8 = ::T.let(nil, ::T.untyped)
  KbF9 = ::T.let(nil, ::T.untyped)
  KbG = ::T.let(nil, ::T.untyped)
  KbH = ::T.let(nil, ::T.untyped)
  KbHome = ::T.let(nil, ::T.untyped)
  KbI = ::T.let(nil, ::T.untyped)
  KbISO = ::T.let(nil, ::T.untyped)
  KbInsert = ::T.let(nil, ::T.untyped)
  KbJ = ::T.let(nil, ::T.untyped)
  KbK = ::T.let(nil, ::T.untyped)
  KbL = ::T.let(nil, ::T.untyped)
  KbLeft = ::T.let(nil, ::T.untyped)
  KbLeftAlt = ::T.let(nil, ::T.untyped)
  KbLeftControl = ::T.let(nil, ::T.untyped)
  KbLeftMeta = ::T.let(nil, ::T.untyped)
  KbLeftShift = ::T.let(nil, ::T.untyped)
  KbM = ::T.let(nil, ::T.untyped)
  KbMinus = ::T.let(nil, ::T.untyped)
  KbN = ::T.let(nil, ::T.untyped)
  KbNumpad0 = ::T.let(nil, ::T.untyped)
  KbNumpad1 = ::T.let(nil, ::T.untyped)
  KbNumpad2 = ::T.let(nil, ::T.untyped)
  KbNumpad3 = ::T.let(nil, ::T.untyped)
  KbNumpad4 = ::T.let(nil, ::T.untyped)
  KbNumpad5 = ::T.let(nil, ::T.untyped)
  KbNumpad6 = ::T.let(nil, ::T.untyped)
  KbNumpad7 = ::T.let(nil, ::T.untyped)
  KbNumpad8 = ::T.let(nil, ::T.untyped)
  KbNumpad9 = ::T.let(nil, ::T.untyped)
  KbNumpadAdd = ::T.let(nil, ::T.untyped)
  KbNumpadDelete = ::T.let(nil, ::T.untyped)
  KbNumpadDivide = ::T.let(nil, ::T.untyped)
  KbNumpadMultiply = ::T.let(nil, ::T.untyped)
  KbNumpadSubtract = ::T.let(nil, ::T.untyped)
  KbO = ::T.let(nil, ::T.untyped)
  KbP = ::T.let(nil, ::T.untyped)
  KbPageDown = ::T.let(nil, ::T.untyped)
  KbPageUp = ::T.let(nil, ::T.untyped)
  KbPeriod = ::T.let(nil, ::T.untyped)
  KbQ = ::T.let(nil, ::T.untyped)
  KbR = ::T.let(nil, ::T.untyped)
  KbReturn = ::T.let(nil, ::T.untyped)
  KbRight = ::T.let(nil, ::T.untyped)
  KbRightAlt = ::T.let(nil, ::T.untyped)
  KbRightControl = ::T.let(nil, ::T.untyped)
  KbRightMeta = ::T.let(nil, ::T.untyped)
  KbRightShift = ::T.let(nil, ::T.untyped)
  KbS = ::T.let(nil, ::T.untyped)
  KbSemicolon = ::T.let(nil, ::T.untyped)
  KbSlash = ::T.let(nil, ::T.untyped)
  KbSpace = ::T.let(nil, ::T.untyped)
  KbT = ::T.let(nil, ::T.untyped)
  KbTab = ::T.let(nil, ::T.untyped)
  KbU = ::T.let(nil, ::T.untyped)
  KbUp = ::T.let(nil, ::T.untyped)
  KbV = ::T.let(nil, ::T.untyped)
  KbW = ::T.let(nil, ::T.untyped)
  KbX = ::T.let(nil, ::T.untyped)
  KbY = ::T.let(nil, ::T.untyped)
  KbZ = ::T.let(nil, ::T.untyped)
  MsLeft = ::T.let(nil, ::T.untyped)
  MsMiddle = ::T.let(nil, ::T.untyped)
  MsOther0 = ::T.let(nil, ::T.untyped)
  MsOther1 = ::T.let(nil, ::T.untyped)
  MsOther2 = ::T.let(nil, ::T.untyped)
  MsOther3 = ::T.let(nil, ::T.untyped)
  MsOther4 = ::T.let(nil, ::T.untyped)
  MsOther5 = ::T.let(nil, ::T.untyped)
  MsOther6 = ::T.let(nil, ::T.untyped)
  MsOther7 = ::T.let(nil, ::T.untyped)
  MsRight = ::T.let(nil, ::T.untyped)
  MsWheelDown = ::T.let(nil, ::T.untyped)
  MsWheelUp = ::T.let(nil, ::T.untyped)
end

class Gosu::Channel
  def current_channel(*_); end
end

class Gosu::Color
  def ==(*_); end

  def _deprecated_abgr(*_); end

  def _deprecated_bgr(*_); end

  def abgr(*args, &block); end

  def bgr(*args, &block); end

  def inspect(*_); end
end

class Gosu::Color
  def self.rgb(*_); end
end

class Gosu::Font
  def _deprecated_draw(*_); end

  def _deprecated_draw_rel(*_); end

  def _deprecated_draw_rot(markup, x, y, z, angle, scale_x=T.unsafe(nil), scale_y=T.unsafe(nil), c=T.unsafe(nil), mode=T.unsafe(nil)); end

  def flags(*_); end

  def set_image(*_); end
end

class Gosu::GLTexInfo
  def bottom=(*bottom); end

  def initialize(*_); end

  def left=(*left); end

  def right=(*right); end

  def tex_name=(*tex_name); end

  def top=(*top); end
end

class Gosu::Image
  def columns(*_); end

  def draw_mod(*_); end

  def inspect(*_); end

  def rows(*_); end
end

class Gosu::Image::BlobHelper
  def self.[](*_); end

  def self.members(); end
end

class Gosu::Song
  def self.current_song(); end

  def self.update(*_); end
end

class Gosu::TextInput
  def initialize(*_); end
end

class Gosu::Window
  def _deprecated_set_mouse_position(*_); end

  def button_down?(*args, &block); end

  def button_id_to_char(*args, &block); end

  def char_to_button_id(*args, &block); end

  def clip_to(*args, &block); end

  def draw_line(*args, &block); end

  def draw_quad(*args, &block); end

  def draw_rect(*args, &block); end

  def draw_triangle(*args, &block); end

  def flush(*args, &block); end

  def gl(*args, &block); end

  def lose_focus(*_); end

  def protected_button_down(*args); end

  def protected_button_up(*args); end

  def protected_draw(*args); end

  def protected_lose_focus(*args); end

  def protected_needs_cursor?(*args); end

  def protected_needs_redraw?(*args); end

  def protected_update(*args); end

  def record(*args, &block); end

  def release_memory(*_); end

  def rotate(*args, &block); end

  def scale(*args, &block); end

  def set_mouse_position(*args, &block); end

  def transform(*args, &block); end

  def translate(*args, &block); end
end

module Gosu::Zen
  def self.included(mod); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def external_encoding(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

module Marshal
  def self.restore(*_); end
end

class Module
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class NameError
  def name(); end

  def receiver(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::Gosu
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
  DOWN = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  LEFT = ::T.let(nil, ::T.untyped)
  OSX_EXECUTABLE = ::T.let(nil, ::T.untyped)
  RIGHT = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  SHAPES = ::T.let(nil, ::T.untyped)
  SHAPES_NEEDED = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  UP = ::T.let(nil, ::T.untyped)
  ZERO_VECTOR = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

module SWIG
end

class SWIG::Pointer
end

class SWIG::Pointer
end

class SWIG::TYPE_p_Gosu__Button
end

class SWIG::TYPE_p_Gosu__Button
end

class SWIG::TYPE_p_Gosu__Channel
end

class SWIG::TYPE_p_Gosu__Channel
end

class SWIG::TYPE_p_Gosu__Color
end

class SWIG::TYPE_p_Gosu__Color
end

class SWIG::TYPE_p_Gosu__Font
end

class SWIG::TYPE_p_Gosu__Font
end

class SWIG::TYPE_p_Gosu__GLTexInfo
end

class SWIG::TYPE_p_Gosu__GLTexInfo
end

class SWIG::TYPE_p_Gosu__Image
end

class SWIG::TYPE_p_Gosu__Image
end

class SWIG::TYPE_p_Gosu__Sample
end

class SWIG::TYPE_p_Gosu__Sample
end

class SWIG::TYPE_p_Gosu__Song
end

class SWIG::TYPE_p_Gosu__Song
end

class SWIG::TYPE_p_Gosu__TextInput
end

class SWIG::TYPE_p_Gosu__TextInput
end

class SWIG::TYPE_p_Gosu__Window
end

class SWIG::TYPE_p_Gosu__Window
end

class SWIG::TYPE_p_char
end

class SWIG::TYPE_p_char
end

class SWIG::TYPE_p_double
end

class SWIG::TYPE_p_double
end

class SWIG::TYPE_p_std__arrayT_double_16_t
end

class SWIG::TYPE_p_std__arrayT_double_16_t
end

class SWIG::TYPE_p_std__string
end

class SWIG::TYPE_p_std__string
end

module SWIG
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SignalException
  def signm(); end

  def signo(); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def reverse!(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end
